## 多进程浏览器

* 进程 & 线程

* 浏览器多进程原因 & 浏览器常见进程分类架构

## TCP/IP 协议

* 网络数据传输通过数据包的形式传输，容易出错和丢失；
* ip 协议负责把数据送到目的主机, UDP 把数据包送到对应应用程序，TCP 把数据完整送到 应用程序；
* UDP & TCP 区别， 各自特点，应用场景；

## 从输入 url 到页面展示这过程发生了什么

> 导航阶段

* 处理用户输入
* url 请求过程
* 准备渲染进程
* 提交文档

> 渲染阶段
* 渲染阶段

## JS, CSS, Html 如何一步一步变成页面

* html 解析器 =》 构建DOM树
* 样式计算
* 布局阶段
* 分层 =》 图层树
* 栅格化操作
* 合成及显示

> repaint（重绘）, reflow（重排）, 合成 的概念及区别

## JS执行机制

> 先编译，后执行

* 动态的，弱类型语言
* 变量提升
* 执行上下文 & 调用栈
* 栈溢出
* 作用域（全局作用域 & 函数作用域 & 块级作用域）
* 作用域链（词法作用域决定，也就是函数声明位置决定，和函数如何调用没关系）

```js

function bar() {
    console.log(myName) // '极客时间'
}
function foo() {
    var myName = " 极客邦 "
    bar()
    console.log(myName) // '极客邦'
}
var myName = " 极客时间 "
foo()
```
* 闭包
> 嵌套的两个函数，内层函数引用了外层函数的变量；
> 外层函数调用返回内层函数；
> 我们把内层函数引用外层函数的变量集合称为外层函数的闭包

* this
> 执行上下文： 变量环境 + 词法环境 + outer + this
> this 不能继承
> 箭头函数自身不能创建执行上下文，this 外层函数 执行上下文；
> 非strict mode： 普通函数 this =》 window；strict mode： 普通函数 this =》 undefined

## V8 工作原理
* js内存中数据存储
* 堆内存 & 栈内存

> 原始数据类型 =》 栈内存； 引用类型 => 堆内存，栈内存中保存引用推内存的地址
* 堆内存存在原因，栈内存数据存储过大的弊端
* 垃圾回收机制
> 内存泄漏：垃圾数据没有得到回收
> 内存溢出：js引擎执行时需要的内存大于阀值
* V8 中垃圾回收器工作机制
* V8 如何执行一段js 代码
> 编译器 & 解释器
> AST
> 字节码
> JIT (即时编译)

## 浏览器中页面循环系统

* 消息队列 & 事件循环
* 浏览器页面单线程缺点
> 如何优先处理高优先级任务
> 如何解决单个任务执行时间过长问题
* 宏任务 & 微任务
* setTimeOut 如何设计实现
> 消息队列，延迟队列（定时器, chromium 内部延迟调用的任务）
* setTimeOut 一些陷阱
> 不一定按时执行
> 嵌套调用的 setTimeOut 系统会设置最短间隔 4ms
> 未激活tab setTimeOut 最小执行时间为 1000ms
> 延时执行时间有最大值
> setTimeout 设置的回调函数中的 this 不符合直觉
* callBack 同步与异步
* XMLHttpRequest 设计思想
* xhr 使用过程中的坑
> 跨域问题（协议，域名，端口号）
> https 混合内容
* Promise 异步编程解决方案
> 消灭混合调用 (回调函数延迟绑定，回调函数返回值穿透)
> 合并多个任务的错误处理 (错误冒泡)
* async/await 同步方式编写异步代码
> Generator 函数, 执行器，协程
> 异步执行 & 隐式返回 Promise

## 浏览器中的页面

* Chrome Devtools使用
* 两个事件： DOMContentLoaded: 页面已经构建好DOM，js，css，html 文件均已经下载完成；Load: 说明浏览器已经加载了所有的资源（图像、样式表等）
* network 面板使用，时间线中各项时间指标含义，以及针对性的优化方案
