## 多进程浏览器

* 进程 & 线程

* 浏览器多进程原因 & 浏览器常见进程分类架构

## TCP/IP 协议

* 网络数据传输通过数据包的形式传输，容易出错和丢失；
* ip 协议负责把数据送到目的主机, UDP 把数据包送到对应应用程序，TCP 把数据完整送到 应用程序；
* UDP & TCP 区别， 各自特点，应用场景；

## 从输入 url 到页面展示这过程发生了什么

> 导航阶段

* 处理用户输入
* url 请求过程
* 准备渲染进程
* 提交文档

> 渲染阶段
* 渲染阶段

## JS, CSS, Html 如何一步一步变成页面

* html 解析器 =》 构建DOM树
* 样式计算
* 布局阶段
* 分层 =》 图层树
* 栅格化操作
* 合成及显示

> repaint（重绘）, reflow（重排）, 合成 的概念及区别

## JS执行机制

> 先编译，后执行

* 动态的，弱类型语言
* 变量提升
* 执行上下文 & 调用栈
* 栈溢出
* 作用域（全局作用域 & 函数作用域 & 块级作用域）
* 作用域链（词法作用域决定，也就是函数声明位置决定，和函数如何调用没关系）

```js

function bar() {
    console.log(myName) // '极客时间'
}
function foo() {
    var myName = " 极客邦 "
    bar()
    console.log(myName) // '极客邦'
}
var myName = " 极客时间 "
foo()
```
* 闭包
> 嵌套的两个函数，内层函数引用了外层函数的变量；
> 外层函数调用返回内层函数；
> 我们把内层函数引用外层函数的变量集合称为外层函数的闭包

* this
> 执行上下文： 变量环境 + 词法环境 + outer + this
> this 不能继承
> 箭头函数自身不能创建执行上下文，this 外层函数 执行上下文；
> 非strict mode： 普通函数 this =》 window；strict mode： 普通函数 this =》 undefined

## V8 工作原理
* js内存中数据存储
* 堆内存 & 栈内存

> 原始数据类型 =》 栈内存； 引用类型 => 堆内存，栈内存中保存引用推内存的地址
* 堆内存存在原因，栈内存数据存储过大的弊端
* 垃圾回收机制
> 内存泄漏：垃圾数据没有得到回收
> 内存溢出：js引擎执行时需要的内存大于阀值
* V8 中垃圾回收器工作机制
* V8 如何执行一段js 代码
> 编译器 & 解释器
> AST
> 字节码
> JIT (即时编译)

## 浏览器中页面循环系统

* 消息队列 & 事件循环
* 浏览器页面单线程缺点
> 如何优先处理高优先级任务
> 如何解决单个任务执行时间过长问题
* 宏任务 & 微任务
* setTimeOut 如何设计实现
> 消息队列，延迟队列（定时器, chromium 内部延迟调用的任务）
* setTimeOut 一些陷阱
> 不一定按时执行
> 嵌套调用的 setTimeOut 系统会设置最短间隔 4ms
> 未激活tab setTimeOut 最小执行时间为 1000ms
> 延时执行时间有最大值
> setTimeout 设置的回调函数中的 this 不符合直觉
* callBack 同步与异步
* XMLHttpRequest 设计思想
* xhr 使用过程中的坑
> 跨域问题（协议，域名，端口号）
> https 混合内容
* Promise 异步编程解决方案
> 消灭混合调用 (回调函数延迟绑定，回调函数返回值穿透)
> 合并多个任务的错误处理 (错误冒泡)
* async/await 同步方式编写异步代码
> Generator 函数, 执行器，协程
> 异步执行 & 隐式返回 Promise

## 浏览器中的页面

* Chrome Devtools使用
* 两个事件： DOMContentLoaded: 页面已经构建好DOM，js，css，html 文件均已经下载完成；Load: 说明浏览器已经加载了所有的资源（图像、样式表等）
* network 面板使用，时间线中各项时间指标含义，以及针对性的优化方案
* DOM -> 表述页面html数据结构，提供 js 操作html 接口， 过滤一些非法（不安全）内容
* DOM 树构建 (html 解析器)
> HTML 解析器维护了一个Token 栈结构
* JS 如何影响DOM 树构建
* CSS 影响首次渲染白屏时间
> JS 阻遏DOM 的构建，JS执行依赖CSSOM
* 优化首页白屏时间
> 调整js，css 为内联模式，减少网络请求，加快DOM解析构建
> 压缩js，css 文件大小，移除无关注释
> 不需要在html解析阶段使用的 js （js执行与DOM无关的操作），使用defer / async 标记
> 对于大的css文件，通过媒体查询设置在特定场景下加载特定文件
* css 动画比 js 高效 
> js 绘制涉及整个渲染流水线，效率低
> css 动画通过为元素设置 will-change ，后续通过合成线程直接替换处理，不占用渲染主线程，效率高
* css 属性 will-change （为元素单独 分一层）(分层，分块，合成)
* 系统性的优化页面渲染
> 加载阶段: 减少关键资源个数；压缩关键资源体积；减少关键资源 RTT 的次数
> 交互阶段：提升渲染进程渲染帧的速度，减少单次js 执行时间；避免强制同步布局；避免布局抖动(尽量不要在修改 DOM 结构时再去查询一些相关值, offsetHeight, clientHeight); 合理利用 CSS 合成动画; 避免频繁的垃圾回收
* 虚拟DOM
> 虚拟DOM解决了什么问题
> 什么是虚拟DOM
> React 最新 更新虚拟DOM 机制 React Fiber
> MVC设计模式
* PWA
* webComponent
> 影子DOM

## 浏览器中的网络

* http/0.9 => 纯html文件传输
* http/1.0 =》 支持多类型文件传输（cache机制）
> 请求头，响应头，响应行，状态码
* http/1.1
> 持久化tcp连接(为每个域名最多支持 6 个 tcp 持久连接)
> 支持服务端发送动态内容
> 虚拟主机支持
> cookie，安全机制
> http/1.1 主要问题： 对带宽利用率不高
> 主要原因：
> 1, tcp 慢启动
> 2, 多条tcp连接 竞争固定带宽
> 3, http/1.1 对头阻塞问题

* http2 多路复用

> 一个域名使用一个tcp长连接传输数据，解决多次tcp慢启动问题和 多个tcp连接竞争固定带宽
> 多路复用。基于 二进制分帧层 
> 可以设置请求的优先级
> 服务器推送
> 头部压缩（请求头 & 响应头）

* http 3 (QUIC 协议)
> http2 主要问题 (TCP 协议问题)
> 队头阻塞
> tcp 建立连接的延时
> tcp 协议僵化
* 同源策略
* XSS: 跨站脚本攻击
> 指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段

> 存储型xss攻击
> 反射型xss 攻击
> 基于DOM xss攻击

> 对付手段
> 服务器对输入脚本进行过滤 和转码
> 充分利用 csp
> 对 重要cookie 设置 httpOnly 属性 （js 无法 读取设置 httpOnly 属性的cookie）

* CSRF: 跨站请求伪造
> 黑客诱导用户点击陌生链接，利用用户的登录状态，在黑客页面对服务器发起非法操作
> 对付手段 （加强服务器的安全稳定性）
> 充分利用 cookie 的 sameSite 属性
> 验证请求来源网站
> 利用 CSRF token
